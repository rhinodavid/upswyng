import {
  JobKind,
  TJobJobrunnerCleanupScriptData,
  TJobJobrunnerCleanupScriptResult,
} from "./workerTypes";

import { App } from "@octokit/app";
import { Job } from "bullmq";
import createBanner from "botbanner";
import { request } from "@octokit/request";

function createOutput(
  commitUrl: string,
  startTime: number,
  endTime: number,
  exitCode: number,
  processJobId: string,
  executeJobId: string,
  cleanupJobId: string,
  nodeScript: string
): string {
  const upswyngbot = `                                                __          __ 
  __  ______  ______      ____  ______  ____ _/ /_  ____  / /_
 / / / / __ \\/ ___| | /| / / / / / __ \\/ __ \`/ __ \\/ __ \\/ __/
/ /_/ / /_/ (__  )| |/ |/ / /_/ / / / / /_/ / /_/ / /_/ / /_  
\\__,_/ .___/____/ |__/|__/\\__, /_/ /_/\\__, /_.___/\\____/\\__/  
    /_/                  /____/      /____/                   `;
  const banner = createBanner(
    [
      ...upswyngbot.split("/n"),
      "",
      "FILE AUTOGENERATED BY UPSWYNGBOT -- DO NOT EDIT",
    ],
    { comment: true }
  );

  let result = "/* eslint-disable */\n\n";
  result += banner;
  result += "\n/*\n";
  if (exitCode !== 0) {
    result += "\n\n";
    result += "*******************************************************\n";
    result += "******** SCRIPT DID NOT COMPLETE SUCCESSFULLY *********\n";
    result += "*******************************************************\n";
    result += "\n\n";
  }
  result += "*****************************************************\n";
  result += `SOURCE COMMIT:   ${commitUrl}\n`;
  result += `EXECUTION START: ${new Date(startTime)}\n`;
  result += `EXECUTION END:   ${new Date(endTime)}\n`;
  result += `RUNTIME:         ${(endTime - startTime) / 1000}s\n`;
  result += `EXIT CODE:       ${exitCode}\n\n`;
  result += `PROCESS JOB ID:  ${processJobId}\n`;
  result += `EXE JOB ID:      ${executeJobId}\n`;
  result += `CLEANUP JOB ID:  ${cleanupJobId}\n`;
  result += "*****************************************************\n";
  result += "                  EXECUTED CODE\n";
  result += "****************************************************/\n\n";
  result += nodeScript + "\n";
  return result;
}

// TODO (rhinodavid): Extract
async function setupGithubApp(
  id: number,
  privateKey: string,
  owner: string,
  repo: string
): Promise<{ app: App; installationId: number }> {
  const CACHE = {};
  const githubApp = new App({
    id,
    privateKey,
    cache: {
      get(key) {
        return CACHE[key];
      },
      set(key, value) {
        CACHE[key] = value;
      },
    },
  });
  const jwt = githubApp.getSignedJsonWebToken();

  // Example of using authenticated app to GET an individual installation
  // https://developer.github.com/v3/apps/#find-repository-installation
  const { data } = await request("GET /repos/:owner/:repo/installation", {
    // TODO: parameterize
    owner: owner,
    repo: repo,
    headers: {
      authorization: `Bearer ${jwt}`,
      accept: "application/vnd.github.machine-man-preview+json",
    },
    mediaType: { previews: ["machine-man"] },
  });

  // contains the installation id necessary to authenticate as an installation
  const installationId = data.id;

  return { app: githubApp, installationId };
}

let githubApp: App | null = null;
let installationId: number | null = null;

/**
 */
export async function processJobJobrunnerCleanupScript(
  job: Job<TJobJobrunnerCleanupScriptData, TJobJobrunnerCleanupScriptResult>,
  appId: number,
  privateKey: string
  /* add github credentials */
): Promise<TJobJobrunnerCleanupScriptResult> {
  if (!appId || !privateKey) {
    throw new Error(
      `Attempted to run Jobrunner Cleanup job ${job.id} for file ${job.data.filename} with no GitHub access`
    );
  }

  const { repository } = job.data;

  const repositoryMatch = repository.match(/(?<owner>[^\/]+)\/(?<repo>\w+)/);
  if (!repositoryMatch) {
    throw new Error(`Unexpected repository string: ${repository}`);
  }
  const { owner, repo } = repositoryMatch.groups;

  if (!githubApp || !installationId) {
    try {
      const result = await setupGithubApp(appId, privateKey, owner, repo);
      githubApp = result.app;
      installationId = result.installationId;
      console.info("üêô Successfully authenticated with GitHub");
    } catch (error) {
      console.warn("üëé Failed to authenticate with GitHub:\n", error);
    }
  }

  if (!githubApp || !installationId) {
    throw new Error(
      "Failed to initialize GitHub integration -- did you provide GitHub credential env credentialss"
    );
  }

  const installationAccessToken = await (githubApp as App).getInstallationAccessToken(
    {
      installationId,
    }
  );

  job.updateProgress(25);

  // create result
  const result = createOutput(
    job.data.commit.url,
    job.data.startTime,
    job.data.endTime,
    job.data.exitCode,
    job.data.processJobId,
    job.data.executeJobId,
    job.id,
    job.data.nodeScript
  );

  // https://regex101.com/r/vvJv5s/5
  const match = job.data.filename.match(
    /^packages\/server\/src\/jobrunner\/exec\/(?<name>.*)\.[t|j]s$/
  );

  if (!match) {
    throw new Error(`Unexpected filename: ${job.data.filename}`);
  }

  // push result to branch
  const resultCommitUrl = await (async function pushNewFileToBranch() {
    const createResponse = await request(
      "PUT /repos/:owner/:repo/contents/:path",
      {
        headers: {
          authorization: `token ${installationAccessToken}`,
        },
        owner: owner,
        repo: repo,
        path: `packages/server/src/jobrunner/logs/${Date.now()}_${
          match.groups.name
        }.log.js`,
        message: `Test commit ${new Date()}`,
        content: Buffer.from(result).toString("base64"),
        branch: "master",
      }
    );

    if (createResponse.status !== 201) {
      throw new Error(
        `Problem creating file, status: ${createResponse.status}`
      );
    }

    return createResponse.data.commit.html_url;
  })();

  job.updateProgress(50);

  const sourceDeleteCommitUrl = await (async function deleteFile() {
    // get sha of source to delete
    const sourceFilePath = job.data.filename;
    const sourceResponse = await request(
      "GET /repos/:owner/:repo/contents/:path",
      {
        headers: {
          authorization: `token ${installationAccessToken}`,
        },
        owner: owner,
        repo: repo,
        path: sourceFilePath,
      }
    );

    const sha = (sourceResponse.data as any).sha as string;

    if (sourceResponse.status !== 200 || !sha.length) {
      throw new Error(
        `Problem getting sha of source: ${JSON.stringify(status, null, 2)}`
      );
    }

    job.updateProgress(75);

    // delete file from branch
    const deleteResponse = await request(
      "DELETE /repos/:owner/:repo/contents/:path",
      {
        headers: {
          authorization: `token ${installationAccessToken}`,
        },
        owner: owner,
        repo: repo,
        path: sourceFilePath,
        message: `Test delete ${new Date()}`,
        branch: "master",
        sha,
      }
    );

    if (deleteResponse.status !== 200) {
      throw new Error(
        `Problem deleting file, status: ${deleteResponse.status}`
      );
    }

    return deleteResponse.data.commit.html_url;
  })();
  job.updateProgress(100);
  return {
    kind: JobKind.JobrunnerCleanupScript,
    sourceDeleteCommitUrl,
    resultCommitUrl,
  };
}
