import {
  JobKind,
  TJobJobrunnerCleanupScriptData,
  TJobJobrunnerCleanupScriptResult,
} from "./workerTypes";

import { App } from "@octokit/app";
import { Job } from "bullmq";
import createBanner from "botbanner";
import { endpoint } from "@octokit/endpoint";
import { request } from "@octokit/request";

const APP_ID = 66587;
const PRIVATE_KEY = `-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAoXuVyCZCa7O0ZXvgSbX+j4aChP0UZEvwesWPVOwFOqNjFrfd
OzFM89Sk/0pmMfqTCb6R8Stw15/lKsr4Le90PTRWfXc5MPwhbdzieHTAB3AoT/Yn
bkCR7lF3ug/pI2KYZDfpgG1gHlKknReMnd7PNDRsnAIH4ZIhtzzlcq60h0xz+xVJ
Q9BxZXTe7NuT8G58ljS11G0z1lemDwtG8xmnQJPT8JwwaEgwmszMDsvRgiGu/kUY
6aUR3AekarWWqS18psdJrLOWlgbjbHIUn3UvrnP+HPCs6RNTk++lwMlwwZK1PhH+
nNUsKqLZfFzV7l89o8P3KCDIogncHi0C2dsvRwIDAQABAoIBAB8qIrYF7Dus6tvL
FHYlUYORig7waMcSgM6w4gCZrEisz6rKwT9zPE6yc0Vxrldm7Ims5a2NnLGAglHH
6i2zUNOfDjIYmEkD38+8GVj17zmAQ8dq0iFNBNzhjCG0gGH73T06LS5D7ZDskihf
KxwsrAB/PZa+LZczBJ7AeeewH9ccc6PGByosnaeK4cuPhStIHipHEatsf1M+wMjZ
de9N2KRnpJF+0BzFl/z7tqGHndrSS81jDwm/jvG6C//UESpdX3EWpIOH1a2WGALZ
TvsfpHJGS4dwJluGfd5jEttEAyoEyGlV2zXroDveuXiz9GeK60REJ6lEVUtVDm75
TZu6OgECgYEA0NwqT1OoCFLJhKMnZo1kqTeubWoPX3MAPtxLhIDWFVF5KYw5zLxB
nDnVmULZyOf/3MuJlaRIl4Xpk1JqW0XNNiSUHSIt0TrESSnlmxjsYn8Lx0lgvpes
Zobtq5/+mUx8F4jHr89AjwRuf6P3m4Jj50M93qy5gxdmvqYhwTCq7WECgYEAxe37
wb8uPj263sW1yCDd6lBU0QclGduwYQ2fj7+/mqHcd6/vEVe12H8CItJ1NBwnMUDX
wnxID8PhjbzOXo6jmUhFMioXJzXHlwCekrIelr2FFLTiZO7a1aKa+A6EmVGg2VV3
jeBjGlNm7LiMeNptRjOFXlKuD6DF5I1sUUP9dacCgYEAuhOszkfl6KR5TWZecAuA
pxIooOphD9TRXy+9SCvQj+WqYM3BoRoICjushYL9rPSlC/16couO8RApbUt73h1u
GtKz8tDEqSgGQHjHS0sFLyupPr+tJaDTw/RqQwGkPsfZts3xujyXc9Oq7qUSsMWW
ZC+QK5cPIC/1Jd21LP1DC4ECgYAgJjCvXrNPLs2so6aMNDJ3fcbZEPUIxzNWAFV7
juS7ZDEgS7ZkNb/2w2KAb3jUFwKSsHqbP36g+OspD5Lhrv+JxUBgDpAmMUkTEOmw
4DexumTkYSEozddDvh63zfvhv22F/6jkpZ7TRtq/9pXyh2AaeAHguUNGjJG4NvRy
Gr4PnwKBgCjf2u7VbDqowwh5bdDWJPMIe92ulVpdU73JCxxW6IkmELEOFx5KJNhi
uUd3CvnJ+suhr7WCCnTlH1N03dbAPfk/w9GVdcFmvpTXOuKSTKk8oFWo8wlx6SBK
74JPKoXVzfLgCy1NnBXmehn16vdL4EyDv8gmkfEKygJnGGtVGbRU
-----END RSA PRIVATE KEY-----`;

function createOutput(
  commitUrl: string,
  startTime: number,
  endTime: number,
  exitCode: number,
  processJobId: string,
  executeJobId: string,
  cleanupJobId: string,
  nodeScript: string
): string {
  const upswyngbot = `                                                __          __ 
  __  ______  ______      ____  ______  ____ _/ /_  ____  / /_
 / / / / __ \\/ ___| | /| / / / / / __ \\/ __ \`/ __ \\/ __ \\/ __/
/ /_/ / /_/ (__  )| |/ |/ / /_/ / / / / /_/ / /_/ / /_/ / /_  
\\__,_/ .___/____/ |__/|__/\\__, /_/ /_/\\__, /_.___/\\____/\\__/  
    /_/                  /____/      /____/                   `;
  const banner = createBanner(
    [
      ...upswyngbot.split("/n"),
      "",
      "FILE AUTOGENERATED BY UPSWYNGBOT -- DO NOT EDIT",
    ],
    { comment: true }
  );

  let result = "/* eslint-disable */";
  result += banner;
  result += "\n/*\n";
  if (exitCode !== 0) {
    result += "\n\n";
    result += "*******************************************************\n";
    result += "******** SCRIPT DID NOT COMPLETE SUCCESSFULLY *********\n";
    result += "*******************************************************\n";
    result += "\n\n";
  }
  result += "*****************************************************\n";
  result += `SOURCE COMMIT:   ${commitUrl}\n`;
  result += `EXECUTION START: ${new Date(startTime)}\n`;
  result += `EXECUTION END:   ${new Date(endTime)}\n`;
  result += `RUNTIME:         ${(endTime - startTime) / 1000}s\n`;
  result += `EXIT CODE:       ${exitCode}\n\n`;
  result += `PROCESS JOB ID:  ${processJobId}\n`;
  result += `EXE JOB ID:      ${executeJobId}\n`;
  result += `CLEANUP JOB ID:  ${cleanupJobId}\n`;
  result += "*****************************************************\n";
  result += "                  EXECUTED CODE\n";
  result += "****************************************************/\n\n";
  result += nodeScript + "\n";
  return result;
}

// TODO (rhinodavid): Extract
async function setupGithubApp(
  id: number,
  privateKey: string,
  owner: string,
  repo: string
): Promise<{ app: App; installationId: number }> {
  const CACHE = {};
  const githubApp = new App({
    id,
    privateKey,
    cache: {
      get(key) {
        return CACHE[key];
      },
      set(key, value) {
        CACHE[key] = value;
      },
    },
  });
  const jwt = githubApp.getSignedJsonWebToken();

  // Example of using authenticated app to GET an individual installation
  // https://developer.github.com/v3/apps/#find-repository-installation
  const { data } = await request("GET /repos/:owner/:repo/installation", {
    // TODO: parameterize
    owner: owner,
    repo: repo,
    headers: {
      authorization: `Bearer ${jwt}`,
      accept: "application/vnd.github.machine-man-preview+json",
    },
    mediaType: { previews: ["machine-man"] },
  });

  // contains the installation id necessary to authenticate as an installation
  const installationId = data.id;

  return { app: githubApp, installationId };
}

let githubApp: App | null = null;
let installationId: number | null = null;

/**
 */
export async function processJobJobrunnerCleanupScript(
  job: Job<TJobJobrunnerCleanupScriptData, TJobJobrunnerCleanupScriptResult>,
  appId: number = APP_ID,
  privateKey: string = PRIVATE_KEY
  /* add github credentials */
): Promise<TJobJobrunnerCleanupScriptResult> {
  if (!appId || !privateKey) {
    throw new Error(
      `Attempted to run Jobrunner Cleanup job ${job.id} for file ${job.data.filename} with no GitHub access`
    );
  }

  const { repository } = job.data;

  const repositoryMatch = repository.match(/(?<owner>[^\/]+)\/(?<repo>\w+)/);
  if (!repositoryMatch) {
    throw new Error(`Unexpected repository string: ${repository}`);
  }
  const { owner, repo } = repositoryMatch.groups;

  if (githubApp || installationId) {
    setupGithubApp(appId, privateKey, owner, repo)
      .then(({ app: _app, installationId: _installationId }) => {
        githubApp = _app;
        installationId = _installationId;
        console.info("ðŸ™ Successfully authenticated with GitHub");
      })
      .catch(error => {
        console.info("ðŸ‘Ž Failed to authenticate with GitHub:\n", error);
      });
  }

  if (!githubApp || installationId) {
    throw new Error(
      "Failed to initialize GitHub integration -- did you provide GitHub credential env credentialss"
    );
  }

  const installationAccessToken = await (githubApp as App).getInstallationAccessToken(
    {
      installationId,
    }
  );

  // create result
  const result = createOutput(
    job.data.commit.url,
    job.data.startTime,
    job.data.endTime,
    job.data.exitCode,
    job.data.processJobId,
    job.data.executeJobId,
    job.id,
    job.data.nodeScript
  );

  // https://regex101.com/r/vvJv5s/5
  const match = job.data.filename.match(
    /^packages\/server\/src\/jobrunner\/exec\/(?<name>.*)\.[t|j]s$/
  );

  if (!match) {
    throw new Error(`Unexpected filename: ${job.data.filename}`);
  }

  // push result to branch
  const resultCommitUrl = await (async function pushNewFileToBranch() {
    const createResponse = await request(
      "PUT /repos/:owner/:repo/contents/:path",
      {
        headers: {
          authorization: `token ${installationAccessToken}`,
        },
        owner: owner,
        repo: repo,
        path: `packages/src/jobrunner/logs/${Date.now()}_${
          match.groups.name
        }.log.js`,
        message: `Test commit ${new Date()}`,
        content: Buffer.from(result).toString("base64"),
        branch: "master",
      }
    );

    if (createResponse.status !== 201) {
      throw new Error(
        `Problem creating file, status: ${createResponse.status}`
      );
    }

    return createResponse.data.commit.html_url;
  })();

  const sourceDeleteCommitUrl = await (async function deleteFile() {
    // get sha of source to delete
    // TODO: put source here
    const sourceFilePath = "package.json"; // for now
    const sourceResponse = await request(
      "GET /repos/:owner/:repo/contents/:path",
      {
        headers: {
          authorization: `token ${installationAccessToken}`,
        },
        owner: owner,
        repo: repo,
        path: sourceFilePath,
      }
    );

    const sha = (sourceResponse.data as any).sha as string;

    if (sourceResponse.status !== 200 || !sha.length) {
      throw new Error(
        `Problem getting sha of source: ${JSON.stringify(status, null, 2)}`
      );
    }

    // delete file from branch
    const deleteResponse = await request(
      "DELETE /repos/:owner/:repo/contents/:path",
      {
        headers: {
          authorization: `token ${installationAccessToken}`,
        },
        owner: owner,
        repo: repo,
        path: sourceFilePath,
        message: `Test delete ${new Date()}`,
        branch: "master",
        sha,
      }
    );

    if (deleteResponse.status !== 200) {
      throw new Error(
        `Problem deleting file, status: ${deleteResponse.status}`
      );
    }

    return deleteResponse.data.commit.html_url;
  })();

  return {
    kind: JobKind.JobrunnerCleanupScript,
    sourceDeleteCommitUrl,
    resultCommitUrl,
  };
}
